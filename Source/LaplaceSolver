import numpy as np
import matplotlib
import matplotlib.pyplot as plt

#system size and resolution
L=2.0
N=21
h=L/(N-1)

q= 3.0
rhoO= q/h**2 # defining a function for charge density (area)
rho= np.zerps ((N,N)) # this  NXN square matric array
rho[N/2,N/2]= rhoO # assing the value for the arry

V= np.zeros((N,N)) # make the intial guess for solution matrix (jacobian method) all zero

#solver
m = 0 #iteration 
eps = 1e-8 # convergence threshold, the difference between Vn and Vn-1
error= 2*eps #dummy error to enter to the first loop

While m < 1 e4 and error > eps:
    V_temp= np.copy(V)
    error=0.0 # we make this accumulate in the loop
    for j in range (1,N-1): # Avoid updating the boundaries 
        for i in range (1, N-1):
            V[i,j] = 0.25*(V_temp[i+1,j] + V_temp [i-1,j] + v_temp [i-1,j]+V_temp[i,j-1]+V_temp [i,j+1] + rho[i,j]*h**2
            error += abs(V[i,j]-V_temp[i,j])
    iteration +=1 # c+=a is the same as c=c+a
    error/= float(N**2) 
print "iteration=", iteration 


# Define arrays used for plotting
x = np.linspace(0,L,N) y = np.linspace(0,L,N) # this is setting an array for x axis and y axis between 0 and L with N numbers in between equally placed 
# meshgrid() by default orders the arrays differently from what # I prefer. This way, (X[i,j],Y[i,j]) equals (x[i],y[j])
Y,X = np.meshgrid(y,x)
# Plot the potential V
matplotlib.rcParams[’xtick.direction’] = ’out’ #rcParamsconfiguration files to customize all kinds of properties
matplotlib.rcParams[’ytick.direction’] = ’out’
CS = plt.contour(X,Y,V,30) # Make a contour plot 
plt.clabel(CS, inline=1, fontsize=10) # Contour labels 
plt.title(’Point charge in the cavity of a grounded box’) 
CB = plt.colorbar(CS, shrink=0.8, extend=’both’) 
plt.show()





